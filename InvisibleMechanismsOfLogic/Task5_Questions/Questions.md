### Счётчик и многопоточность

#### Вопрос:

Создаётся 10 потоков, каждый из которых увеличивает глобальный счетчик 100000 раз. Однако итоговое значение счетчика может 
быть неверным, почему? Объясните и напишите правильный вариант.

#### Ответ:

Возникает состояние гонки при чтении и записи переменной, поскольку операция инкремента не атомарна. Несколько потоков 
могут инкрементировать одно и то же значение счётчика или неверно перезаписать его. Пример:

```
Thread 1: - Читает counter = 5 из памяти -> Инкремент counter = counter + 1 -> counter = 6 записывает в память

Thread 2: - Читает counter = 5 из памяти -> Инкремент counter = counter + 1 -> counter = 6 записывает в память
```

Таким образом вместо корректной инкрементации до 7, переменная становится 6. 

На C# можно использовать для инкремента `Interlocked.Increment(ref counter)`, который наиболее оптимизирован для таких операций
(не использует под капотом Mutex или Semaphore, вызывает специальные процессорные инструкции);

### Взаимная блокировка

#### Вопрос:

Два потока конкурируют за общие ресурсы, но в результате возникает взаимная блокировка, почему? Объясните и напишите правильный вариант.

#### Ответ:

Дедлок произойдёт поскольку к моменту выполнения вложенных конструкций потоки уже будут держать lock1 и lock2, что вызовет взаимную блокировку.
Порядок будет такой:

1. Thread 1 захватывает lock1;
2. Thread 2 захватывает lock2;
3. Thread 1 доходит до lock2 и будет ожидать пока Thread 2 его отпустит;
4. Thread 2 доходит до lock1 и будет ожидать пока Thread 1 его отпустит;

В итоге каждый из потоков ждёт другого.

Исправить это можно вызывая lock1 и lock2 в одинаковом порядке, тогда:
1. Thread 1 захватывает lock1;
2. Thread 2 ожидает lock1;
3. Thread 1 захватывает lock2;
4. Thread 1 отпускает lock2;
5. Thread 1 отпускает lock1;
6. Thread 2 захватывает lock1;
7. Thread 2 захватывает lock2;
8. Thread 2 отпускает lock2;
9. Thread 2 отпускает lock1;
10. Finish.